01- الكتلة البرمجية (Code Block) والإزاحة (Indentation)

في هذا القسم سنتعرف على كيفية تنظيم بايثون للأكواد، وهو مفهوم يختلف عن لغات البرمجة الأخرى التي تستخدم الأقواس { }.

أولاً: الكتلة البرمجية (Code Block)
- التعريف: هي مجموعة من الأسطر البرمجية التي تنتمي لشرط معين أو حلقة تكرارية أو دالة، وتُنفذ جميعها معاً كوحدة واحدة.
- ميزة بايثون: تستخدم بايثون "الإزاحة" لتحديد بداية ونهاية الكتلة البرمجية بدلاً من الأقواس.

ثانياً: الإزاحة (Indentation) أو المساحة البيضاء
- التعريف: هي الفراغ الموجود في بداية السطر البرمجي.
- دورها: تخبر بايثون أن هذا السطر "يتبع" السطر الذي قبله وهو جزء من كتلته البرمجية.
- المقدار: المتعارف عليه عالمياً هو (4 مسافات) أو ضغطة واحدة على زر (Tab)، ويجب الالتزام بنفس المقدار في كل الكتلة.

ثالثاً: هل مقدار الإزاحة مقيد؟
- تقنياً: بايثون تقبل أي عدد من المسافات (مسافة واحدة أو أكثر)، لكن "بشرط" أن تكون جميع الأسطر داخل نفس الكتلة لها نفس مقدار الإزاحة بالضبط.
- القاعدة الذهبية: إذا بدأت الكتلة بـ 4 مسافات، يجب أن تلتزم بـ 4 مسافات لكل سطر تابع لها، وإلا سيظهر خطأ (IndentationError).

رابعاً: أمثلة توضيحية

مثال لكود صحيح (إزاحة منتظمة):
if 5 > 2:
    print("Five is greater than two")
    print("This is inside the block")
الناتج:
Five is greater than two
This is inside the block

مثال لكود خاطئ (إزاحة غير منتظمة):
if 5 > 2:
    print("Step 1")
  print("Step 2")
الناتج:
سيظهر خطأ (IndentationError) لأن السطر الثاني لم يلتزم بنفس مستوى الفراغ.

خامساً: أهمية النقطتين الرأسيتين (:)
- القاعدة: دائماً قبل البدء بكتلة برمجية جديدة (بعد If أو For أو While)، يجب وضع نقطتين رأسيين (:) في نهاية السطر، ثم النزول لسطر جديد مع ترك الإزاحة.





02- الجمل الشرطية (Conditional Statements)

تُستخدم الجمل الشرطية لتنفيذ أكواد معينة فقط عند تحقق شرط محدد.

أولاً: جملة if و elif و else
تُستخدم لاختبار عدة شروط متتالية. يبدأ المفسر بالشرط الأول (if)، وإذا لم يتحقق ينتقل لما بعده (elif)، وفي حال فشل جميع الشروط يتم تنفيذ (else).

مثال عملي:
سنتحقق من رمز الاستجابة (response_code) الذي يدخله المستخدم:

response_code = int(input('Enter the response code: '))

if (response_code == 200):
    print('OK')
elif (response_code == 201):
    print('Created')
elif (response_code == 300):
    print('Multiple Choices')
elif (response_code == 404):
    print('Not Found')
else:
    print('Are you sure this is an HTTP code?')

الناتج (عند إدخال 404):
Not Found

ثانياً: جملة Match Case (البديل الحديث لـ Switch)
في الإصدارات الحديثة من بايثون، تمت إضافة جملة match التي تشبه "Switch" في اللغات الأخرى، وهي أكثر تنظيماً عند وجود خيارات كثيرة.

مثال عملي (من صورة الكود المرفقة):
match response_code:
    case 200:
        print('OK')
    case 201:
        print('Created')
    case 300:
        print('Multiple Choices')
    case 404:
        print('Not Found')

ثالثاً: ملاحظات هامة حول الأمثلة
1. الإزاحة (Indentation): لاحظ أن جمل الطباعة print تم دفعها للداخل بمقدار 4 مسافات لأنها تابعة للشرط.
2. النقطتان الرأسيتان (:): يجب وضعها بعد كل شرط (if, elif, else) وبعد كل (case) لإعلام بايثون ببداية الكتلة.
3. نوع البيانات: تم استخدام دالة int() قبل دالة input() لتحويل النص المدخل إلى رقم صحيح ليتمكن البرنامج من مقارنته بالأرقام (200, 404..).




03 الحلقات التكرارية :

For. While.
 هي أدوات تسمح لك بتنفيذ نفس مجموعة الأوامر بشكل متكرر.

مثال

arab_cities = {
    "Morocco": "Rabat",
    "Egypt": "Cairo",
    "Saudi Arabia": "Riyadh",
    "Algeria": "Algiers",
    "Tunisia": "Tunis"
}

for country, capital in arab_cities.items():
        print(f"The capital of {country} is: {capital}")


ملخص حلقة while في لغة بايثون
1. المفهوم الأساسي:
تُستخدم حلقة while لتكرار تنفيذ مجموعة من الأوامر طالما أن الشرط المعطى يظل صحيحاً (True). بمجرد أن يصبح الشرط خاطئاً (False)، يتوقف البرنامج عن التكرار وينتقل لما بعد الحلقة.
2. مخاطر الحلقة اللانهائية (Infinite Loop):
إذا لم يتضمن كود الحلقة أمراً يغير من قيمة الشرط (مثل زيادة العداد)، ستستمر الحلقة في العمل للأبد.
استهلاك الموارد: تؤدي الحلقات التي لا تنتهي إلى إجهاد المعالج (CPU) بنسبة 100%، وإذا كانت الحلقة تُخزن بيانات جديدة في كل دورة، فستمتلئ الذاكرة العشوائية (RAM) بسرعة، مما يؤدي إلى انهيار النظام (System Crash).
3. أدوات التحكم (Break & Continue):
break: تقوم بكسر الحلقة والخروج منها فوراً مهما كانت حالة الشرط.
continue: تقوم بتخطي الكود المتبقي في "الدورة الحالية" والقفز مباشرة إلى بداية الدورة التالية لاختبار الشرط مرة أخرى.
4. ميزة بايثون الخاصة (while ... else):
تسمح بايثون بإضافة كتلة else بعد while. يتم تنفيذها فقط إذا انتهت الحلقة "بشكل طبيعي" (أي عندما يصبح الشرط False). أما إذا انتهت الحلقة بسبب break، فإن كتلة else يتم تجاهلها.

x = 0
while x < 5:
    print(f"X = {x}")
    x += 1
else:
    print("End.") 


i = 0
while i < 10:
    i += 1
    
    if i == 2:
        continue  
    if i == 6:
        break     
        
    print(f"Number: {i}")
    


"""
### ملخص بانيات هياكل البيانات (Comprehensions) ###

بانيات البيانات هي وسيلة مختصرة وذكية في بايثون لإنشاء القوائم والمجموعات والقواميس في سطر واحد.
تتميز بأنها أكثر كفاءة (أسرع) وتجعل الكود أنظف من استخدام حلقات for التقليدية.

1. باني القوائم [List Comprehension]:
- الأقواس: مربعة [ ].
- الخصائص: تُنتج قائمة مرتبة، وتسمح بتكرار العناصر.
- مثال (مربعات الأعداد الزوجية):
  even_squares_list = [i**2 for i in range(10) if i % 2 == 0]
  # النتيجة: [0, 4, 16, 36, 64]

2. باني المجموعات {Set Comprehension}:
- الأقواس: متعرجة { }.
- الخصائص: تُنتج عناصر فريدة فقط (تحذف التكرار تلقائياً)، والترتيب فيها غير ثابت.
- مثال (مربعات الأعداد الزوجية كقيم فريدة):
  even_squares_set = {i**2 for i in range(10) if i % 2 == 0}
  # النتيجة: {0, 64, 4, 36, 16}

3. باني القواميس {Dict Comprehension}:
- الأقواس: متعرجة {key: value}.
- الخصائص: تُنشئ روابط بين مفاتيح وقيم، وتظهر مرتبة تصاعدياً حسب المدخلات في النسخ الحديثة.
- مثال (العدد الزوجي كمفتاح ومربعه كقيمة):
  even_squares_dict = {i: i**2 for i in range(10) if i % 2 == 0}
  # النتيجة: {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
"""

# تطبيق عملي للمقارنة بين الثلاثة في سطر واحد لكل نوع:
numbers = range(10)

# 1. القائمة (List)
list_comp = [i**2 for i in numbers if i % 2 == 0]

# 2. المجموعة (Set)
set_comp = {i**2 for i in numbers if i % 2 == 0}

# 3. القاموس (Dictionary)
dict_comp = {i: i**2 for i in numbers if i % 2 == 0}

print(f"List: {list_comp}")
print(f"Set:  {set_comp}")
print(f"Dict: {dict_comp}")




"""
### ملخص الدوال (Functions) في بايثون ###

1. أنواع الدوال:
- الدوال المبنية مسبقاً (Built-in Functions): دوال جاهزة في بايثون مثل print() و len().
- الدوال المعرفة من قبل المستخدم (User-defined Functions): التي ننشئها باستخدام كلمة 'def'.

2. الوسائط الموضعية (Positional Arguments):
هي الوسائط التي تعتمد على "الترتيب". يجب تمرير القيم بنفس ترتيب المتغيرات في تعريف الدالة.

3. الوسائط المفتاحية (Keyword Arguments):
هي الوسائط التي يتم تمريرها مع ذكر "اسم المتغير". ميزتها أنها تسمح بتغيير ترتيب الوسائط عند استدعاء الدالة.
"""

# --- مثال توضيحي يجمع النوعين ---

def describe_person(name, age, city):
    print(f"{name} is {age} years old and lives in {city}.")

# 1. استدعاء باستخدام الوسائط الموضعية (الترتيب مهم جداً هنا)
# Positional Arguments: name="Ali", age=25, city="Rabat"
describe_person("Ali", 25, "Rabat")

# 2. استدعاء باستخدام الوسائط المفتاحية (الترتيب غير مهم هنا)
# Keyword Arguments: نحدد كل قيمة لأي متغير تذهب
describe_person(city="Cairo", name="Sara", age=30)

# --- الدوال مع القيم الافتراضية (Default Parameters) ---
def greet(name, message="Welcome"):
    print(f"Hello {name}, {message}")
