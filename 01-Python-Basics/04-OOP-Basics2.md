.
01


مفهوم التغليف (Encapsulation)

هو أحد الأركان الأربعة للبرمجة الكائنية. يهدف إلى إخفاء البيانات الداخلية للكائن ومنع الوصول المباشر إليها من خارج الصنف، مع توفير واجهة محددة للتعامل معها.
2. محددات الوصول (Access Modifiers)
تُستخدم للتحكم في مدى ظهور وخصوصية البيانات:
عام (Public): يمكن الوصول إليه من أي مكان داخل أو خارج الصنف.
محمي (Protected): يُشار إليه بشرطة واحدة _. يهدف لتنبيه المبرمج بأن المتغير مخصص للاستخدام الداخلي وللأصناف الوارثة، لكن بايثون لا تمنع الوصول إليه فعلياً.
خاص (Private): يُشار إليه بشرطتين __. يمنع الوصول المباشر للمتغير من خارج الصنف.
3. دور الـ Getters والـ Setters
بما أن البيانات مغلفة (خاصة)، نستخدم توابع وسيطة للتعامل معها:
Getters: توابع لاسترجاع (قراءة) قيمة الخاصية المغلفة.
Setters: توابع لتعديل (كتابة) قيمة الخاصية مع إمكانية إضافة شروط للتحقق من صحة القيمة.


class Product:
    def __init__(self, name, price):
        self.name = name          # عام (Public)
        self.__price = price     # خاص (Private) باستخدام __

    # Getter: تابع لقراءة السعر الخاص
    def get_price(self):
        return str(self.__price) + ' $'

    # Setter: تابع لتعديل السعر الخاص
    def set_price(self, new_price):
        if new_price >= 0:
            self.__price = new_price
        else:
            print("Error: Price cannot be negative")

# إنشاء كائن
iphone_14 = Product('iPhone 14', 999)

# الوصول عبر Getter
print(iphone_14.get_price())  # سيطبع: 999 $

# التعديل عبر Setter
iphone_14.set_price(1100)
print(iphone_14.get_price())  # سيطبع: 1100 $

02
. الوراثة (Inheritance)
تعتبر الوراثة من أهم ركائز البرمجة كائنية التوجه، حيث تسمح بإنشاء صنف جديد يعتمد على صنف موجود مسبقاً، مما يساهم في تقليل تكرار الكود وتسهيل صيانته.
المفاهيم التقنية:
الصنف الأساسي (Base/Parent Class): هو الصنف الذي يحتوي على الخصائص والوظائف العامة المشتركة.
الصنف المشتق (Derived/Child Class): هو الصنف الذي يرث من الأساسي، ويستطيع إضافة خصائص جديدة أو تعديل الوظائف الموروثة.
أنواع الوراثة في بايثون:
الوراثة الفردية (Single Inheritance): أن يرث صنف من صنف واحد فقط.
الوراثة المتعددة (Multiple Inheritance): أن يرث صنف واحد من عدة أصناف أساسية في وقت واحد.
الوراثة متعددة المستويات (Multi-level Inheritance): أن يرث صنف من صنف مشتق (علاقة الجد، الأب، والابن).
مثال تطبيقي شامل:
شرح الرموز المستخدمة:
_variable (شرطة واحدة): تعني "محمي". هي اتفاق ودي بين المبرمجين بعدم لمس المتغير مباشرة.
__variable (شرطتان): تعني "خاص". يقوم بايثون بتغيير اسم المتغير داخلياً (Name Mangling) ليجعل الوصول إليه من الخارج صعباً جداً، مما يجبر المبرمج على استخدام getters و setters

# الصنف الأساسي (القالب العام للمنتجات)
class Product:
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price

    def display_basic_info(self):
        print(f"ID: {self.id} | Name: {self.name} | Price: {self.price}")

# الوراثة: الصنف Mobile يرث كل شيء من Product
class Mobile(Product):
    def __init__(self, id, name, price, storage):
        # استدعاء دالة البناء من الصنف الأساسي باستخدام super()
        super().__init__(id, name, price)
        # إضافة خاصية جديدة خاصة بالهواتف فقط
        self.storage = storage

    # إضافة تابع جديد خاص بالهواتف
    def display_full_specs(self):
        self.display_basic_info() # استدعاء تابع موروث
        print(f"Storage: {self.storage}GB")

# إنشاء كائن من الصنف المشتق
my_phone = Mobile(101, "iPhone 15", 1200, 256)

# استخدام التوابع الموروثة والخاصة
my_phone.display_full_specs()

ملاحظات برمجية هامة:
دالة super(): تُستخدم لتمرير البيانات من الصنف المشتق إلى الصنف الأساسي، مما يضمن تفعيل دالة البناء __init__ في الصنف الأب.
إعادة التعيين (Overriding): يمكن للصنف المشتق أن يعيد كتابة دالة موروثة بنفس الاسم ليغير طريقة عملها بما يتناسب مع احتياجاته الجديدة.
