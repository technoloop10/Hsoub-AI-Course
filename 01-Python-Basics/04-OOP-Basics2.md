.
01


مفهوم التغليف (Encapsulation)

هو أحد الأركان الأربعة للبرمجة الكائنية. يهدف إلى إخفاء البيانات الداخلية للكائن ومنع الوصول المباشر إليها من خارج الصنف، مع توفير واجهة محددة للتعامل معها.
2. محددات الوصول (Access Modifiers)
تُستخدم للتحكم في مدى ظهور وخصوصية البيانات:
عام (Public): يمكن الوصول إليه من أي مكان داخل أو خارج الصنف.
محمي (Protected): يُشار إليه بشرطة واحدة _. يهدف لتنبيه المبرمج بأن المتغير مخصص للاستخدام الداخلي وللأصناف الوارثة، لكن بايثون لا تمنع الوصول إليه فعلياً.
خاص (Private): يُشار إليه بشرطتين __. يمنع الوصول المباشر للمتغير من خارج الصنف.
3. دور الـ Getters والـ Setters
بما أن البيانات مغلفة (خاصة)، نستخدم توابع وسيطة للتعامل معها:
Getters: توابع لاسترجاع (قراءة) قيمة الخاصية المغلفة.
Setters: توابع لتعديل (كتابة) قيمة الخاصية مع إمكانية إضافة شروط للتحقق من صحة القيمة.


class Product:
    def __init__(self, name, price):
        self.name = name          # عام (Public)
        self.__price = price     # خاص (Private) باستخدام __

    # Getter: تابع لقراءة السعر الخاص
    def get_price(self):
        return str(self.__price) + ' $'

    # Setter: تابع لتعديل السعر الخاص
    def set_price(self, new_price):
        if new_price >= 0:
            self.__price = new_price
        else:
            print("Error: Price cannot be negative")

# إنشاء كائن
iphone_14 = Product('iPhone 14', 999)

# الوصول عبر Getter
print(iphone_14.get_price())  # سيطبع: 999 $

# التعديل عبر Setter
iphone_14.set_price(1100)
print(iphone_14.get_price())  # سيطبع: 1100 $

02
. الوراثة (Inheritance)
تعتبر الوراثة من أهم ركائز البرمجة كائنية التوجه، حيث تسمح بإنشاء صنف جديد يعتمد على صنف موجود مسبقاً، مما يساهم في تقليل تكرار الكود وتسهيل صيانته.
المفاهيم التقنية:
الصنف الأساسي (Base/Parent Class): هو الصنف الذي يحتوي على الخصائص والوظائف العامة المشتركة.
الصنف المشتق (Derived/Child Class): هو الصنف الذي يرث من الأساسي، ويستطيع إضافة خصائص جديدة أو تعديل الوظائف الموروثة.
أنواع الوراثة في بايثون:
الوراثة الفردية (Single Inheritance): أن يرث صنف من صنف واحد فقط.
الوراثة المتعددة (Multiple Inheritance): أن يرث صنف واحد من عدة أصناف أساسية في وقت واحد.
الوراثة متعددة المستويات (Multi-level Inheritance): أن يرث صنف من صنف مشتق (علاقة الجد، الأب، والابن).
مثال تطبيقي شامل:
شرح الرموز المستخدمة:
_variable (شرطة واحدة): تعني "محمي". هي اتفاق ودي بين المبرمجين بعدم لمس المتغير مباشرة.
__variable (شرطتان): تعني "خاص". يقوم بايثون بتغيير اسم المتغير داخلياً (Name Mangling) ليجعل الوصول إليه من الخارج صعباً جداً، مما يجبر المبرمج على استخدام getters و setters

# الصنف الأساسي (القالب العام للمنتجات)
class Product:
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price

    def display_basic_info(self):
        print(f"ID: {self.id} | Name: {self.name} | Price: {self.price}")

# الوراثة: الصنف Mobile يرث كل شيء من Product
class Mobile(Product):
    def __init__(self, id, name, price, storage):
        # استدعاء دالة البناء من الصنف الأساسي باستخدام super()
        super().__init__(id, name, price)
        # إضافة خاصية جديدة خاصة بالهواتف فقط
        self.storage = storage

    # إضافة تابع جديد خاص بالهواتف
    def display_full_specs(self):
        self.display_basic_info() # استدعاء تابع موروث
        print(f"Storage: {self.storage}GB")

# إنشاء كائن من الصنف المشتق
my_phone = Mobile(101, "iPhone 15", 1200, 256)

# استخدام التوابع الموروثة والخاصة
my_phone.display_full_specs()

ملاحظات برمجية هامة:
دالة super(): تُستخدم لتمرير البيانات من الصنف المشتق إلى الصنف الأساسي، مما يضمن تفعيل دالة البناء __init__ في الصنف الأب.
إعادة التعيين (Overriding): يمكن للصنف المشتق أن يعيد كتابة دالة موروثة بنفس الاسم ليغير طريقة عملها بما يتناسب مع احتياجاته الجديدة.




03
التجريد (Abstraction)
التجريد هو عملية إخفاء التفاصيل المعقدة لطريقة عمل الوظائف، وإظهار "الواجهة" الخارجية فقط للمستخدم. الهدف منه هو التركيز على "ماذا" يفعله الكائن، وليس "كيف" يقوم به داخلياً.
المفاهيم التقنية:
الأصناف المجردة (Abstract Classes): هي أصناف "نظرية" لا يمكن إنشاء كائنات (Objects) منها مباشرة. تُستخدم فقط كقالب أساسي للأصناف الأخرى.
التوابع المجردة (Abstract Methods): هي دوال يتم تعريفها في الصنف الأساسي بدون كتابة كود برمجى داخلها، ويُجبر أي صنف وارث على إعادة كتابة هذه الدوال وتحديد طريقة عملها.
كيفية تطبيق التجريد في بايثون:
نستخدم مكتبة مدمجة تسمى abc (اختصار لـ Abstract Base Classes).
مثال تطبيقي شامل:

from abc import ABC, abstractmethod

# تعريف صنف مجرد (لا يمكن إنشاء كائن منه)
class Shape(ABC):
    
    @abstractmethod
    def area(self):
        """تابع مجرد لحساب المساحة - يجب تعريفه في الأصناف الوارثة"""
        pass

    @abstractmethod
    def perimeter(self):
        """تابع مجرد لحساب المحيط - يجب تعريفه في الأصناف الوارثة"""
        pass

# صنف وارث (يجب عليه تطبيق التوابع المجردة)
class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side * self.side

    def perimeter(self):
        return 4 * self.side

        

# إنشاء كائن من الصنف الوارث
my_square = Square(5)
print(f"Area: {my_square.area()}")
print(f"Perimeter: {my_square.perimeter()}")
لماذا نستخدم التجريد؟
فرض معايير محددة: إجبار جميع المبرمجين الذين يرثون من الصنف الأساسي على اتباع هيكل معين وتسميات موحدة للدوال.
تقليل التعقيد: المستخدم يحتاج فقط لمعرفة اسم الدالة ووظيفتها، دون الحاجة لفهم الكود المعقد الذي يعمل في الخلفية.
الأمان: منع إنشاء كائنات من أصناف عامة جداً لا معنى لها في الواقع (مثل إنشاء كائن من صنف "شكل" دون تحديد نوعه).
